<!DOCTYPE html>
<html lang="it">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
    <link href="stile.css" rel="stylesheet" type="text/css">
    <link href="animate.css" rel="stylesheet" type="text/css">
    <title>IntCatch</title>
    <script src="jquery-3.4.1.js" type="text/javascript"></script>
    <script src="scripts.js" type="text/javascript"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <script type="text/javascript">

    c=1;
    d=1;
    img_video=[150,30];

    var a;
    function inizialization(){
      c=1;
      d=1;
      document.getElementById("immagine").src="dataset/ter"+d+"_"+c+".png";
      document.getElementById("immagine1").src="dataset/ter"+d+"_"+c+"-annotation.png";
     var x = document.getElementById("selectimage");
        while (x.length > 0) {x.remove(x.length-1);}
        var x = document.getElementById("selectvideo");
        while (x.length > 0) {x.remove(x.length-1);}
      for(i=0;i<img_video.length;i++){
        var option=document.createElement("option");
        option.text="video "+(i+1);
        option.value=i;
        document.getElementById("selectvideo").add(option);
      }
      for(i=0;i<img_video[0];i++){
        var option=document.createElement("option");
        option.text="immagine "+(i+1);
        option.value=i;
        document.getElementById("selectimage").add(option);
      }
      document.getElementById("selectvideo").selectedIndex=0;
      document.getElementById("selectimage").selectedIndex=0;


    }


    function changevideo(){
      var x = document.getElementById("selectimage");
      while (x.length > 0) {x.remove(x.length-1);}
        switch(document.getElementById("selectvideo").value){
          case "0":
          for(i=0;i<img_video[0];i++){
            d=1;
            changeimage()
            var option=document.createElement("option");
            option.text="immagine "+(i+1);
            option.value=i;
            x.add(option);}
            break;
          case "1":
          d=2;
          changeimage()
            for(i=0;i<img_video[1];i++){
            var option=document.createElement("option");
            option.text="immagine "+(i+1);
            option.value=i;
            x.add(option);}
            break;
        }
    document.getElementById("selectimage").selectedIndex=0;
    }


    function avanti(){
      if (c+1>selectimage.length){
        c=1;
      }
      else{
        c++
      }

      document.getElementById("immagine1").src="dataset/ter"+d+"_"+c+"-annotation.png";
      document.getElementById("immagine").src="dataset/ter"+d+"_"+c+".png";
      document.getElementById('selectimage').selectedIndex=c-1;
      clearInterval(myTimer);
      }


    function indietro(){
      if (c-1==0){
        c=selectimage.length;
      }
      else{
        c--;
      }
      document.getElementById("immagine1").src="dataset/ter"+d+"_"+c+"-annotation.png";
      document.getElementById("immagine").src="dataset/ter"+d+"_"+c+".png";
      document.getElementById('selectimage').selectedIndex=c-1;
      clearInterval(myTimer);

    }


    function changeimage(){
      c=document.getElementById('selectimage').value;
      c++;
      document.getElementById("immagine1").src="dataset/ter"+d+"_"+c+"-annotation.png";
      document.getElementById("immagine").src="dataset/ter"+d+"_"+c+".png";
    }

    function Download(){
      window.open("dataset.zip");
    }


    </script>
  </head>
  <body onload="inizialization()">

    <div id="top" class="item animated fadeIn">
      <div id="titolo"><h1 style="; font-family: serif; font-size: 3em;">Water Detection</h1></div>
      <div id="indice"><a id="freccia_indice"></a>&nbsp;&nbsp;&nbsp;&nbsp;INDICE
      <div id="Menu"><br><a href="#Intro" style="text-decoration:none;color:black;">INTRODUZIONE</a><br>
                    <a href="#tool" style="text-decoration:none;color:black">TOOL DI SEGMENTAZIONE</a><br>
                    <a href="#dataset" style="text-decoration:none;color:black">DATASET</a><br> <br>
    </div></div>
    </div>

    <div id="Intro" style="position:relative;top :20px;color:white;padding-left:5%;padding-right:5%;">
      <h1>Introduzione</h1>
      <p>
        In questa pagina presenteremo uno studio effettuato dall'universit&agrave; di Verona sull'automatizzazione di droni acquatici. I droni utilizzati sono AVS a basso costo e il loro scopo finale &egrave; dare un'alternativa valida al monitoraggio delle acque. Questi droni, infatti, hanno lo scopo ultimo di campionare automaticamente le acque dove sono posti cosi da evitare il campionamento manuale da parte di utenti specifici. Con questa modalit&agrave; gli enti addetti a queste operazioni avranno benefici economici, dato il costo computazionale e sensoriale dei droni, e temporali, rendendo pi&ugrave; semplice e immediata la modalita di prelievo di campioni.
      </p><p>
        Concentreremo l'attenzione sul processo di riconoscimento della linea di galleggiamento e di ostacoli tramite l'utilizzo di reti neurali. Una rete neurale &egrave; un ottimo strumento per classificare immagini. Nel nostro caso vengono classificati i pixel di ogni singolo frame provenienti da videocamere montate sopra i droni. Una volta classificati i dati, il drone potrà essere mosso di conseguenza evitando così ostacoli presenti nel suo percorso.
      </p><p>
        Una rete neurale prima di essere caricata sul drone deve essere addestrata a svolgere il suo compito e testata per valutarne il funzionamento. L'addestramento consinste nel caricare un dataset appositamente creato come input per la rete cosi da fargli aggiustare i propri parametri. Per l'addestramento della rete neurale vengono utilizzate immagini provenienti da video appositamente registrati. La rete neurale una volta addestrata verrà testata su immagini provenienti da un dataset diverso da quello di training. Una volta caricata sul drone dovrà essere in grado di lavorare con i frame provenienti dalle videocamere per riconscere dal vivo la presenza di ostacoli e della linea di costa.
      </p>
        <!--La detection viene fatta attraverso il training di una rete neurale. Le reti neurali sono uno strumento informatico nato durante gli anni '50 ma sviluppatosi soltanto negli ultimi anni grazie alle tecnologie avanzate e alle grandi potenze di calcolo sviluppate. Una rete neurale è composta da tanti strati di centinaia/migliaia di neuroni i quali ognuno ha lo scopo di calcolare una sommatoria pesata dei dati che arrivano dalle varie sinapsi e passarle allo strato successivo.
        Per la fase di training verrà dato in input un grande numero di frame gia etichettati cosi che, grazie all'aiuto di specifiche tecniche e calcoli (ad esempio algoritmi specifici di backPropagation e funzioni di costo), possa aggiustare i propri parametri al fine di rinoscere al meglio la natura di ogni pixel. Per creare il dataset bisogna etichettare ogni pixel di ogni frame disponibile da video pertinenti. Per fare ciò bisogna creare una nuova immagine (una mask) da dare come etichetta all'immagine originale in cui a ogni pixel viene associata una classe di appartenenza.
        set di immagini ognuna associata ad una maschera appositamente creata in cui ad ogni posizione di pixel viene associata una particolare classe di appartenenza
        -->
    </div>
    <div style="position:relative; top :30px;" >
      <div id="tool"> <h1>Tool di segmentazione</h1>
        <p>
          Per creare il dataset utile in questo ambito &egrave; stato usato un tool creato appositamente.<br> <a href="#immagine_tool" style="color:orange">L'immagine 1<a> mostra un esempio di schermata del tool utilizzato.<br>
          Con questo programma &egrave; possibile segmentare l'immagine con tre diversi metodi presenti nella libreria Skimage di Python:<br>
          <ul>
            <li> <b>SLIC</b> (Simple Linear Iterative Clustering): Segmenta l'immagine usando l'algoritmo di clustering k-means nello spazio dei colori (x,y,z). </li>
            <li> <b>Felzenszwalb</b>: Produce una sovra-segmentazione di un'immagine multicanale (i.e RGB) utilizzando un clustering rapido e minimo basato su spanning tree sulla griglia dell'immagine. Il parametro sigma &egrave; il diametro di un kernel Gaussiano, usato per fare smoothing dell'immagine prima della segmentazione.</li>
            <li> <b>Quickshift</b>: Produce una sovra-segmentazione dell'immagine usando l'algoritmo di ricerca quickshift. Questo algoritmo, pur essendo molto efficacie, rende la segmentazione molto lenta.</li>
          </ul>
          Per una spiegazione dettagliata all'utilizzo dei vari metodi utilizzati vi rimando al sito della <a href="https://scikit-image.org/docs/0.12.x/api/skimage.segmentation.html#id3" style="color:orange">libreria Python Skimage</a>.
        </p><p>
        Una volta segmentata l'immagine &egrave; possibile etichettare le regioni di pixel con una specifica classe. Nel nostro caso sono state utilizzate 5 superclassi (es. ostacoli in acqua) per raggruppare oggetti di natura simile in questo contesto.
        Ogni etichetta &egrave; associata ad un colore (consultabili nella <a href="#legenda" style="color:orange">legenda</a>) cos&igrave; che, una volta che si vuole concludere l'operazione di labeling, viene creata una maschera di dimensioni uguali all'immagine di partenza in cui ogni pixel colorato corrisponde all'etichetta del pixel dell'immagine di partenza.<br>
        Per la creazione del datset sono stati usati video registrati al lago di Garda e sul fiume Ter in Spagna. Per ampliare il dataset e gli scenari sono state anche usate immagini pubbliche disponibili al sito <a href="" style="color:orange;">asas</a>.<br>Una parte delle immagini del dataset con le corrispondenti maschere sono consultabili nella sezione <a href="#dataset" style="color:orange">Dataset</a> con la possibilit&agrave; di fare Download.
      </p><p>Durante la creazione della rete è possibile anche lavorare sul dataset con l'operazione di data Augmentation. Questa tecnica permette di aumentare artificialmente le dimensioni del dataset usando operazioni come insversione, rotazione e luminosità di sottoimmagini dell'immagine originale. L'ampliamento del dataset può aumentare la capacità di generalizzazione della rete.
      </div>
      <div id="prova" >
        <div id="immagine_tool" class="img_didasc">
          <img style="position:relative;width:90%;left:5%;" src="tool.png"/>
          <p id="didasc">Immagine 1: Esempio di schermata Tool di segmentazione.</p>
        </div>
        <div id="legenda"> <b>LEGENDA COLORI</b>:
          <dl>
            <dt><span class="dot1" style="position:absolute;height:10px;width:10px;background-color:#6464FF;display:inline;border-radius:50%"><dd>acqua</dd></span></td>

            <dt><span class="dot2" style="position:absolute;height:10px;width:10px;background-color:#00FF00;display:inline;border-radius:50%"></span></dt>
              <dd>costa</dd>
            <dt><span class="dot3" style="position:absolute;height:10px;width:10px;background-color:#FF00FF;display:inline;border-radius:50%"></span></dt>
              <dd>cielo</dd>
            <dt><span class="dot4" style="position:absolute;height:10px;width:10px;background-color:#FF0000;display:inline;border-radius:50%"></span></dt>
              <dd>ostacoli in acqua</dd>
            <dt><span class="dot5" style="position:absolute;height:10px;width:10px;background-color:#C8C814;display:inline;border-radius:50%"></span></dt>
              <dd>animali in acqua</dd>
          </dl>
        </div>
      </div>
    </div>
    <div class="box" id ="dataset">
      <h1>Dataset</h1>
    </div>
    <div class="box">
      <button id="bottoneDownload" onclick="Download()">Download</button>
    </div>
    <div class="box">
      <select id="selectvideo" onchange="changevideo()">
      </select>
      <select id="selectimage" onchange="changeimage()">
      </select>
      <a href="javascript:inizialization()" class="testo">reset</a>
    </div>
    <div id="box_immagini" class="item animated zoomIn">
      <div id="im" ><img id="immagine" class="immagine"> <a id="bottone1" onclick="indietro()"></a></div>
      <div id="im1"><img id="immagine1" class="immagine" > <a id="bottone2"onclick="avanti()"></a> </div>
    </div>
    <div style="position :relative;"></div>

  <div style="position:relative;top:50px;color:white;padding-left:5%;">

    <p>Una volta completata la creazione del dataset, quest'ultimo deve essere suddiviso casualmente in 3 cartelle. Ogni dataset servirà per una determinata fase di creazione di una rete neurale. Le tre fasi sono:
      <ul><li><b>Training</b></li>
        <li><b>Validation</b></li>
        <li><b>Testing</b></li>
      </ul>
      Ogni singola parte andiamo ad analizzare l'architettura della nostra rete.
    </p>
  </div>
  <div style="position:relative; top:20px;color:white;padding-left:5%;">
    <h1>Architettura Rete</h1>
    <p style="color:white;">Come architettura di rete è stata usata una CNN (Convolutional Neural Network). Questo tipo di architettura mostra buone prestazioni per la classificazione di immagini. Più precisamente viene utilizzata un'architettura U-net ovvero
      L'architettura U-net è stata sviluppato da Olaf Ronneberger et al. per la Bio Image Segmentation. L'architettura contiene due percorsi. Il primo percorso è il percorso di codifica che viene utilizzato per acquisire il contesto nell'immagine. L'encoder è solo una pila tradizionale di strati convoluzionali e di max-pooling. Il secondo percorso è il percorso di decodifica che viene utilizzato per abilitare la localizzazione precisa utilizzando convoluzioni trasposte. Quindi è una rete completamente convoluzionale (FCN) end-to-end, cioè contiene solo livelli Convolutional e non contiene alcun livello Dense a causa del quale può accettare immagini di qualsiasi dimensione.
    </p>
  </div>
  <a id="back_to_top"></a>
  <div id="postMenu"><div id="aperto"><div style="position:relative;width:100%; height:50px;"><h3>INDICE</h3></div><br><a href="#Intro" style="text-decoration:none;color:black;">INTRODUZIONE</a><br>
                <a href="#tool" style="text-decoration:none;color:black">TOOL DI SEGMENTAZIONE</a><br>
                <a href="#dataset" style="text-decoration:none;color:black">DATASET</a><br> <br>
              </div></div>
  </body>
</html>
